import * as fs from "fs";
import * as path from "path";
import { getConfig } from "../config";

/**
 * Script to generate TypeScript types for KiCad symbols and footprints.
 * Scans standard KiCad library paths on macOS and project-local libraries.
 */

const KICAD_PATH = "/Applications/KiCad/KiCad.app/Contents/SharedSupport";
const SYMBOLS_DIR = path.join(KICAD_PATH, "symbols");
const FOOTPRINTS_DIR = path.join(KICAD_PATH, "footprints");

function parseSymbolsInFile(filePath: string, libName: string): string[] {
    if (!fs.existsSync(filePath)) return [];
    const content = fs.readFileSync(filePath, "utf-8");
    const names: string[] = [];

    // Quick regex to find all (symbol "NAME" ...) top-level patterns
    const matches = content.matchAll(/\(symbol\s+"([^"]+)"/g);
    for (const match of matches) {
        const symName = match[1];
        // Skip if it contains a colon already (might be an alias or complex name)
        if (!symName.includes(":")) {
            names.push(`${libName}:${symName}`);
        } else {
            names.push(symName);
        }
    }
    return names;
}

function getSymbolNames(projectLibDir: string): string[] {
    const names: string[] = [];

    // System libraries
    if (fs.existsSync(SYMBOLS_DIR)) {
        const symbolFiles = fs.readdirSync(SYMBOLS_DIR).filter(f => f.endsWith(".kicad_sym"));
        for (const file of symbolFiles) {
            const libName = path.basename(file, ".kicad_sym");
            names.push(...parseSymbolsInFile(path.join(SYMBOLS_DIR, file), libName));
        }
    }

    // Project library
    const projectSymLib = path.join(projectLibDir, "Project_Symbols.kicad_sym");
    if (fs.existsSync(projectSymLib)) {
        names.push(...parseSymbolsInFile(projectSymLib, "Project_Symbols"));
    }

    // Built-in markers
    names.push("Device:DNC");
    names.push("Connector:TestPoint");

    return [...new Set(names)].sort();
}

function getFootprintNames(projectLibDir: string): string[] {
    const names: string[] = [];

    // System libraries
    if (fs.existsSync(FOOTPRINTS_DIR)) {
        const prettyDirs = fs.readdirSync(FOOTPRINTS_DIR).filter(d => d.endsWith(".pretty"));
        for (const dir of prettyDirs) {
            const libName = path.basename(dir, ".pretty");
            const modFiles = fs.readdirSync(path.join(FOOTPRINTS_DIR, dir)).filter(f => f.endsWith(".kicad_mod"));

            for (const file of modFiles) {
                const fpName = path.basename(file, ".kicad_mod");
                names.push(`${libName}:${fpName}`);
            }
        }
    }

    // Project library
    const projectFpLib = path.join(projectLibDir, "Project_Footprints.pretty");
    if (fs.existsSync(projectFpLib)) {
        const modFiles = fs.readdirSync(projectFpLib).filter(f => f.endsWith(".kicad_mod"));
        for (const file of modFiles) {
            const fpName = path.basename(file, ".kicad_mod");
            names.push(`Project_Footprints:${fpName}`);
        }
    }

    // Built-in markers
    names.push("DNC");
    names.push("TestPoint:TestPoint_Pad_D2.5mm");

    return [...new Set(names)].sort();
}

export async function cmdTypes(args: string[]): Promise<void> {
    console.log("ðŸš€  Syncing KiCad library types...\n");

    const { projectRoot } = getConfig();
    const projectLibDir = path.join(projectRoot, ".kicad");

    // Output file should be in the user's project src folder
    const outputFile = path.join(projectRoot, "src/kicad-library.ts");

    if (!fs.existsSync(path.dirname(outputFile))) {
        fs.mkdirSync(path.dirname(outputFile), { recursive: true });
    }

    const symbols = getSymbolNames(projectLibDir);
    const footprints = getFootprintNames(projectLibDir);

    const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by pcb types
 */

export type KicadLibrarySymbol =
${symbols.map(s => `  | "${s}"`).join("\n")};

export type KicadLibraryFootprint =
${footprints.map(f => `  | "${f}"`).join("\n")};
`;

    fs.writeFileSync(outputFile, content, "utf-8");
    console.log(`  âœ… Generated ${symbols.length} symbols and ${footprints.length} footprints.`);
    console.log(`  ðŸ“‚ Output: ${outputFile}`);
}
