import { CircuitSnapshot, Pin } from "../synth/types";
import { Component } from "../synth/Component";
import { Net } from "../synth/Net";
import { SymbolLibrary, SymbolDefinition } from "./SymbolLibrary";
import { SExpr, SExpressionParser } from "./SExpressionParser";
import { UuidManager } from "./UuidManager";

export class NetlistGenerator {
  private snapshot: CircuitSnapshot;
  private library: SymbolLibrary;
  private uuids: UuidManager;
  private usedSymbols = new Map<string, SymbolDefinition>();
  private schematicPath: string;

  constructor(snapshot: CircuitSnapshot, library: SymbolLibrary, uuids: UuidManager, schematicPath: string = "") {
    this.snapshot = snapshot;
    this.library = library;
    this.uuids = uuids;
    this.schematicPath = schematicPath || snapshot.name;
  }

  generate(): string {
    const rootUuid = this.uuids.getOrGenerate("ROOT");

    const netlist: SExpr[] = [
      "export",
      ["version", this.quote("E")],
      ["design",
        ["source", this.quote(this.schematicPath)],
        ["date", this.quote(new Date().toISOString())],
        ["tool", this.quote("Eeschema 9.0.7")],
        ["sheet", ["number", '"1"'], ["name", '"/"'], ["tstamps", '"/"'],
          ["title_block",
            ["title", this.quote(this.snapshot.name)],
            ["company", this.quote("Generated by @tobisk/pcbs")],
            ["rev", this.quote("v1.0")],
            ["date", this.quote(new Date().toISOString().split("T")[0])],
            ["source", this.quote(`${this.snapshot.name}.kicad_sch`)],
            ["comment", ["number", '"1"'], ["value", '""']],
            ["comment", ["number", '"2"'], ["value", '""']],
            ["comment", ["number", '"3"'], ["value", '""']],
            ["comment", ["number", '"4"'], ["value", '""']],
            ["comment", ["number", '"5"'], ["value", '""']],
            ["comment", ["number", '"6"'], ["value", '""']],
            ["comment", ["number", '"7"'], ["value", '""']],
            ["comment", ["number", '"8"'], ["value", '""']],
            ["comment", ["number", '"9"'], ["value", '""']]
          ]
        ]
      ],
      this.generateComponents(),
      this.generateLibParts(),
      this.generateLibraries(),
      this.generateNets()
    ];

    return SExpressionParser.serialize(netlist);
  }

  private generateComponents(): SExpr {
    const components: SExpr[] = ["components"];
    for (const comp of this.snapshot.components) {
      if (comp.symbol === "Device:DNC") continue;

      const symName = comp.symbol;
      const uuid = this.uuids.getOrGenerate(comp.ref);

      // Collect symbol for libparts later
      const symDef = this.library.getSymbol(comp.symbol);
      if (symDef) {
        this.addSymbol(symDef);
      }

      const symNameParts = symName.split(":");
      const libName = symNameParts.length > 1 ? symNameParts[0] : "Lib";
      const partName = symNameParts.length > 1 ? symNameParts.slice(1).join(":") : symName;

      const rootUuid = this.uuids.getOrGenerate("ROOT");

      const fields: SExpr[] = ["fields"];
      fields.push(["field", ["name", this.quote("LCSC_Part")], this.quote(comp.partNo || "")]);
      fields.push(["field", ["name", this.quote("ki_keywords")], '""']);
      fields.push(["field", ["name", this.quote("hierarchy_path")], this.quote(`/${rootUuid}`)]);
      fields.push(["field", ["name", this.quote("root_uuid")], this.quote(rootUuid)]);
      fields.push(["field", ["name", this.quote("Footprint")], this.quote(comp.footprint || "")]);
      fields.push(["field", ["name", this.quote("Datasheet")], '""']);
      fields.push(["field", ["name", this.quote("Description")], this.quote(comp.description || "")]);

      const compDef: SExpr[] = [
        "comp",
        ["ref", this.quote(comp.ref)],
        ["value", this.quote(comp.value || symName)],
        ["footprint", this.quote(comp.footprint || "")],
        fields,
        ["libsource", ["lib", this.quote(libName)], ["part", this.quote(partName)], ["description", this.quote(comp.description || "")]],
      ];

      compDef.push(["property", ["name", this.quote("LCSC_Part")], ["value", this.quote(comp.partNo || "")]]);
      compDef.push(["property", ["name", this.quote("ki_keywords")], ["value", '""']]);
      compDef.push(["property", ["name", this.quote("hierarchy_path")], ["value", this.quote(`/${rootUuid}`)]]);
      compDef.push(["property", ["name", this.quote("root_uuid")], ["value", this.quote(rootUuid)]]);
      compDef.push(["property", ["name", this.quote("Sheetname")], ["value", this.quote("Stammblatt")]]);
      compDef.push(["property", ["name", this.quote("Sheetfile")], ["value", this.quote(`${this.snapshot.name}.kicad_sch`)]]);
      compDef.push(["sheetpath", ["names", '"/"'], ["tstamps", '"/"']]);
      compDef.push(["tstamps", this.quote(uuid)]);

      components.push(compDef);
    }
    return components;
  }

  private generateLibParts(): SExpr {
    const libparts: SExpr[] = ["libparts"];
    for (const symDef of this.usedSymbols.values()) {
      const parts = this.extractLibPart(symDef);
      if (parts) {
        libparts.push(parts);
      }
    }
    return libparts;
  }

  private extractLibPart(symDef: SymbolDefinition): SExpr | null {
    const pins: SExpr[] = ["pins"];
    const foundPins = new Set<string>();

    const scan = (expr: SExpr) => {
      if (!Array.isArray(expr)) return;
      for (const item of expr) {
        if (Array.isArray(item) && item[0] === "symbol") {
          scan(item);
        } else if (Array.isArray(item) && item[0] === "pin") {
          const nameItem = item.find(i => Array.isArray(i) && i[0] === "name") as SExpr[];
          const numItem = item.find(i => Array.isArray(i) && i[0] === "number") as SExpr[];
          const type = item[1] as string;

          if (nameItem && numItem && numItem[1]) {
            const num = SExpressionParser.unquote(numItem[1] as string);
            const name = nameItem[1] ? SExpressionParser.unquote(nameItem[1] as string) : num;

            if (!foundPins.has(num)) {
              foundPins.add(num);
              pins.push([
                "pin",
                ["num", this.quote(num)],
                ["name", this.quote(name)],
                ["type", type]
              ]);
            }
          }
        }
      }
    };

    scan(symDef.definition);
    for (const dep of symDef.dependencies) {
      scan(dep);
    }

    let referencePrefix = "U";

    // Scan definition and dependencies to find the Reference property, needed for extended symbols
    const checkExprForRef = (expr: SExpr) => {
      if (!Array.isArray(expr)) return;
      for (const item of expr) {
        if (Array.isArray(item) && item[0] === "property") {
          const propName = SExpressionParser.unquote(item[1] as string);
          if (propName === "Reference" && item[2]) {
            referencePrefix = SExpressionParser.unquote(item[2] as string);
            return;
          }
        }
      }
    };

    checkExprForRef(symDef.definition);
    if (referencePrefix === "U") {
      for (const dep of symDef.dependencies) {
        checkExprForRef(dep);
        if (referencePrefix !== "U") break;
      }
    }

    const symNameParts = symDef.name.split(":");
    const libName = symNameParts.length > 1 ? symNameParts[0] : "Lib";
    const partName = symNameParts.length > 1 ? symNameParts.slice(1).join(":") : symDef.name;

    return [
      "libpart",
      ["lib", this.quote(libName)],
      ["part", this.quote(partName)],
      ["description", '""'],
      ["docs", '"~"'],
      [
        "fields",
        ["field", ["name", '"Reference"'], this.quote(referencePrefix)],
        ["field", ["name", '"Value"'], this.quote(partName)],
        ["field", ["name", '"Footprint"'], '""'],
        ["field", ["name", '"Datasheet"'], '"~"'],
        ["field", ["name", '"Description"'], '""']
      ],
      pins
    ];
  }

  private generateLibraries(): SExpr {
    const libraries: SExpr[] = ["libraries"];
    // Collect unique libraries from symbols
    const uniqueLibs = new Set<string>();
    for (const [name, symDef] of this.usedSymbols.entries()) {
      const symNameParts = name.split(":");
      uniqueLibs.add(symNameParts.length > 1 ? symNameParts[0] : "Lib");
    }
    for (const lib of uniqueLibs) {
      // Best effort absolute URI depending on Standard Library or Project Symbols
      let uri = "";
      if (lib === "Project_Symbols") {
        uri = `\${KIPRJMOD}/../../../.kicad/Project_Symbols.kicad_sym`;
      } else {
        uri = `/Applications/KiCad/KiCad.app/Contents/SharedSupport/symbols//${lib}.kicad_sym`;
      }
      libraries.push(["library", ["logical", this.quote(lib)], ["uri", this.quote(uri)]]);
    }
    return libraries;
  }

  private generateNets(): SExpr {
    const nets: SExpr[] = ["nets"];
    let code = 1;

    const pinMap = new Map<Pin, Component<any>>();
    for (const comp of this.snapshot.components) {
      if (comp.symbol === "Device:DNC") continue;
      for (const [name, pin] of comp.allPins) {
        pinMap.set(pin as Pin, comp);
      }
    }

    const processedNets = new Set<Net>();

    const allNets = new Set<Net>(this.snapshot.nets);
    for (const comp of this.snapshot.components) {
      for (const [_, pin] of comp.allPins) {
        if (pin.net) allNets.add(pin.net);
      }
    }

    // Sort nets: GND first, then power nets (+5V, +3V3, etc.) inverted, then rest
    const sortedNets = Array.from(allNets).sort((a, b) => {
      const isGndA = a.name.toLowerCase().includes("gnd");
      const isGndB = b.name.toLowerCase().includes("gnd");
      if (isGndA && !isGndB) return -1;
      if (!isGndA && isGndB) return 1;

      const isPwrA = a.name.startsWith("+");
      const isPwrB = b.name.startsWith("+");
      if (isPwrA && !isPwrB) return -1;
      if (!isPwrA && isPwrB) return 1;
      if (isPwrA && isPwrB) return b.name.localeCompare(a.name); // +5V before +3V3

      return a.name.localeCompare(b.name);
    });

    for (const net of sortedNets) {
      if (processedNets.has(net)) continue;
      processedNets.add(net);

      const nodes: SExpr[] = [];

      for (const [pin, comp] of pinMap) {
        if (pin.net === net) {
          let pintype = "passive";
          const symDef = this.library.getSymbol(comp.symbol);
          if (symDef) {
            // Helper to recursively find pin type by pin number
            const findPinType = (expr: SExpr, targetPin: string): string | null => {
              if (!Array.isArray(expr)) return null;

              // Is this a pin definition? (pin "type" "shape" ...)
              if (expr[0] === "pin" && typeof expr[1] === "string" && typeof expr[2] === "string") {
                // Find the (number "X" ...) child
                for (const child of expr) {
                  if (Array.isArray(child) && child[0] === "number" && typeof child[1] === "string") {
                    const num = SExpressionParser.unquote(child[1]);
                    if (num === targetPin) {
                      return expr[1]; // The pin type is the second element
                    }
                  }
                }
              }

              // Recurse
              for (const child of expr) {
                const res = findPinType(child, targetPin);
                if (res) return res;
              }
              return null;
            };

            pintype = findPinType(symDef.definition, pin.name) || "passive";
            if (pintype === "passive") {
              for (const dep of symDef.dependencies) {
                const depType = findPinType(dep, pin.name);
                if (depType) {
                  pintype = depType;
                  break;
                }
              }
            }
          }

          nodes.push(["node", ["ref", this.quote(comp.ref)], ["pin", this.quote(pin.name)], ["pintype", this.quote(pintype)]]);
        }
      }

      nets.push([
        "net",
        ["code", this.quote(code.toString())],
        ["name", this.quote(net.name)],
        ["class", this.quote("Default")],
        ...nodes
      ]);
      code++;
    }

    return nets;
  }

  private addSymbol(symDef: SymbolDefinition) {
    if (this.usedSymbols.has(symDef.name)) return;
    this.usedSymbols.set(symDef.name, symDef);
  }

  private quote(s: string): string {
    return `"${s.replace(/"/g, '\\"')}"`;
  }
}
