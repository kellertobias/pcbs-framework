import { CircuitSnapshot, Pin } from "../synth/types";
import { Component } from "../synth/Component";
import { Net } from "../synth/Net";
import { SymbolLibrary, SymbolDefinition } from "./SymbolLibrary";
import { SExpr, SExpressionParser } from "./SExpressionParser";
import { UuidManager } from "./UuidManager";
import * as path from "path";

export class NetlistGenerator {
  private snapshot: CircuitSnapshot;
  private library: SymbolLibrary;
  private uuids: UuidManager;
  private usedSymbols = new Map<string, SymbolDefinition>();
  private schematicPath: string;

  constructor(snapshot: CircuitSnapshot, library: SymbolLibrary, uuids: UuidManager, schematicPath: string = "") {
    this.snapshot = snapshot;
    this.library = library;
    this.uuids = uuids;
    this.schematicPath = schematicPath || snapshot.name;
  }

  generate(): string {
    const rootUuid = this.uuids.getOrGenerate("ROOT");

    const netlist: SExpr[] = [
      "export",
      ["version", this.quote("E")],
      ["design",
        ["source", this.quote(this.schematicPath)],
        ["date", this.quote(new Date().toISOString())],
        ["tool", this.quote("Eeschema 9.0.7")],
        ["sheet", ["number", '"1"'], ["name", '"/"'], ["tstamps", '"/"'],
          ["title_block",
            ["title", this.quote(this.snapshot.name)],
            ["company", this.quote("Generated by @tobisk/pcbs")],
            ["rev", this.quote("v1.0")],
            ["date", this.quote(new Date().toISOString().split("T")[0])],
            ["source", this.quote(`${this.snapshot.name}.kicad_sch`)],
            ["comment", ["number", '"1"'], ["value", '""']],
            ["comment", ["number", '"2"'], ["value", '""']],
            ["comment", ["number", '"3"'], ["value", '""']],
            ["comment", ["number", '"4"'], ["value", '""']],
            ["comment", ["number", '"5"'], ["value", '""']],
            ["comment", ["number", '"6"'], ["value", '""']],
            ["comment", ["number", '"7"'], ["value", '""']],
            ["comment", ["number", '"8"'], ["value", '""']],
            ["comment", ["number", '"9"'], ["value", '""']]
          ]
        ]
      ],
      this.generateComponents(),
      this.generateLibParts(),
      this.generateLibraries(),
      this.generateNets()
    ];

    return SExpressionParser.serialize(netlist);
  }

  private generateComponents(): SExpr {
    const components: SExpr[] = ["components"];
    for (const comp of this.snapshot.components) {
      if (comp.symbol === "Device:DNC") continue;

      const symName = comp.symbol;
      const uuid = this.uuids.getOrGenerate(comp.ref);

      // Collect symbol for libparts later
      const symDef = this.library.getSymbol(comp.symbol);
      if (symDef) {
        this.addSymbol(symDef);
      }

      const symNameParts = symName.split(":");
      const libName = symNameParts.length > 1 ? symNameParts[0] : "Lib";
      const partName = symNameParts.length > 1 ? symNameParts.slice(1).join(":") : symName;

      const rootUuid = this.uuids.getOrGenerate("ROOT");

      const compProps = new Map<string, string>();
      if (symDef) {
        const extractProps = (expr: SExpr) => {
          if (!Array.isArray(expr)) return;
          for (const item of expr) {
            if (Array.isArray(item) && item[0] === "property" && typeof item[1] === "string" && typeof item[2] === "string") {
              const pName = SExpressionParser.unquote(item[1]);
              const pVal = SExpressionParser.unquote(item[2]);
              if (!compProps.has(pName)) compProps.set(pName, pVal);
            }
          }
        };
        for (const dep of symDef.dependencies) extractProps(dep);
        extractProps(symDef.definition);
      }

      const kiKeywords = compProps.get("ki_keywords");
      const kiFpFilters = compProps.get("ki_fp_filters");

      const fields: SExpr[] = ["fields"];
      fields.push(["field", ["name", this.quote("Datasheet")]]);
      if (comp.description) {
        fields.push(["field", this.quote(comp.description), ["name", this.quote("Description")]]);
      } else {
        fields.push(["field", ["name", this.quote("Description")]]);
      }
      if (comp.footprint) {
        fields.push(["field", this.quote(comp.footprint), ["name", this.quote("Footprint")]]);
      } else {
        fields.push(["field", ["name", this.quote("Footprint")]]);
      }
      fields.push(["field", this.quote(`/${rootUuid}`), ["name", this.quote("hierarchy_path")]]);
      fields.push(["field", ["name", this.quote("ki_keywords")]]);
      if (comp.partNo) {
        fields.push(["field", this.quote(comp.partNo), ["name", this.quote("LCSC_Part")]]);
      } else {
        fields.push(["field", ["name", this.quote("LCSC_Part")]]);
      }
      fields.push(["field", this.quote(rootUuid), ["name", this.quote("root_uuid")]]);

      const compDef: SExpr[] = [
        "comp",
        ["ref", this.quote(comp.ref)],
        ["value", this.quote(comp.value || symName)],
        ["footprint", this.quote(comp.footprint || "")],
        fields,
        ["libsource", ["lib", this.quote(libName)], ["part", this.quote(partName)], ["description", this.quote(comp.description || "")]],
      ];

      compDef.push(["property", ["name", this.quote("hierarchy_path")], ["value", this.quote(`/${rootUuid}`)]]);
      if (kiFpFilters !== undefined) {
        compDef.push(["property", ["name", this.quote("ki_fp_filters")], ["value", this.quote(kiFpFilters)]]);
      }
      compDef.push(["property", ["name", this.quote("ki_keywords")], ["value", '""']]);
      if (kiKeywords !== undefined) {
        compDef.push(["property", ["name", this.quote("ki_keywords")], ["value", this.quote(kiKeywords)]]);
      }
      compDef.push(["property", ["name", this.quote("LCSC_Part")], ["value", this.quote(comp.partNo || "")]]);
      compDef.push(["property", ["name", this.quote("root_uuid")], ["value", this.quote(rootUuid)]]);
      compDef.push(["property", ["name", this.quote("Sheetname")], ["value", this.quote("Stammblatt")]]);
      compDef.push(["property", ["name", this.quote("Sheetfile")], ["value", this.quote(`${this.snapshot.name}.kicad_sch`)]]);
      compDef.push(["sheetpath", ["names", '"/"'], ["tstamps", '"/"']]);
      compDef.push(["tstamps", this.quote(uuid)]);

      components.push(compDef);
    }
    return components;
  }

  private generateLibParts(): SExpr {
    const libparts: SExpr[] = ["libparts"];
    for (const symDef of this.usedSymbols.values()) {
      const parts = this.extractLibPart(symDef);
      if (parts) {
        libparts.push(parts);
      }
    }
    return libparts;
  }

  private extractLibPart(symDef: SymbolDefinition): SExpr | null {
    const pins: SExpr[] = ["pins"];
    const foundPins = new Set<string>();

    const scan = (expr: SExpr) => {
      if (!Array.isArray(expr)) return;
      for (const item of expr) {
        if (Array.isArray(item) && item[0] === "symbol") {
          scan(item);
        } else if (Array.isArray(item) && item[0] === "pin") {
          const nameItem = item.find(i => Array.isArray(i) && i[0] === "name") as SExpr[];
          const numItem = item.find(i => Array.isArray(i) && i[0] === "number") as SExpr[];
          const type = item[1] as string;

          if (nameItem && numItem && numItem[1]) {
            const num = SExpressionParser.unquote(numItem[1] as string);
            let name = nameItem[1] ? SExpressionParser.unquote(nameItem[1] as string) : num;
            if (name === "~") name = "";

            if (!foundPins.has(num)) {
              foundPins.add(num);
              pins.push([
                "pin",
                ["num", this.quote(num)],
                ["name", this.quote(name)],
                ["type", this.quote(type)]
              ]);
            }
          }
        }
      }
    };

    scan(symDef.definition);
    for (const dep of symDef.dependencies) {
      scan(dep);
    }

    const libpartProps = new Map<string, string>();
    const extractLibProps = (expr: SExpr) => {
      if (!Array.isArray(expr)) return;
      for (const item of expr) {
        if (Array.isArray(item) && item[0] === "property" && typeof item[1] === "string" && typeof item[2] === "string") {
          const pName = SExpressionParser.unquote(item[1]);
          const pVal = SExpressionParser.unquote(item[2]);
          if (!libpartProps.has(pName)) libpartProps.set(pName, pVal);
        }
      }
    };
    for (const dep of symDef.dependencies) extractLibProps(dep);
    extractLibProps(symDef.definition);

    const description = libpartProps.get("Description") || "";
    const docs = libpartProps.get("Datasheet") || "~";
    const footprintFromProp = libpartProps.get("Footprint") || "";
    let referencePrefix = libpartProps.get("Reference") || "U";

    const symNameParts = symDef.name.split(":");
    const libName = symNameParts.length > 1 ? symNameParts[0] : "Lib";
    const partName = symNameParts.length > 1 ? symNameParts.slice(1).join(":") : symDef.name;

    const footprints: SExpr[] = ["footprints"];
    const fpFilters = libpartProps.get("ki_fp_filters");
    if (fpFilters) {
      const filters = fpFilters.split(/\s+/).filter(Boolean);
      for (const f of filters) {
        footprints.push(["fp", this.quote(f)]);
      }
    }

    const libpartNode: SExpr[] = [
      "libpart",
      ["lib", this.quote(libName)],
      ["part", this.quote(partName)],
      ["description", this.quote(description)],
      ["docs", this.quote(docs)]
    ];

    if (footprints.length > 1) {
      libpartNode.push(footprints);
    }

    const libpartFields: SExpr[] = ["fields"];
    libpartFields.push(["field", ["name", '"Reference"'], this.quote(referencePrefix)]);
    libpartFields.push(["field", ["name", '"Value"'], this.quote(partName)]);
    if (footprintFromProp) {
      libpartFields.push(["field", ["name", '"Footprint"'], this.quote(footprintFromProp)]);
    } else {
      libpartFields.push(["field", ["name", '"Footprint"']]);
    }
    if (docs !== "~" && docs !== "") {
      libpartFields.push(["field", ["name", '"Datasheet"'], this.quote(docs)]);
    } else {
      libpartFields.push(["field", ["name", '"Datasheet"'], '"~"']);
    }
    if (description) {
      libpartFields.push(["field", ["name", '"Description"'], this.quote(description)]);
    } else {
      libpartFields.push(["field", ["name", '"Description"']]);
    }
    libpartNode.push(libpartFields);

    libpartNode.push(pins);

    return libpartNode;
  }

  private generateLibraries(): SExpr {
    const libraries: SExpr[] = ["libraries"];
    // Collect unique libraries from symbols
    const uniqueLibs = new Set<string>();
    for (const [name, symDef] of this.usedSymbols.entries()) {
      const symNameParts = name.split(":");
      uniqueLibs.add(symNameParts.length > 1 ? symNameParts[0] : "Lib");
    }
    for (const lib of uniqueLibs) {
      // Best effort absolute URI depending on Standard Library or Project Symbols
      let uri = "";
      if (lib === "Project_Symbols") {
        const outputDir = path.dirname(this.schematicPath);
        uri = path.resolve(outputDir, "../../../.kicad/Project_Symbols.kicad_sym");
      } else {
        uri = `/Applications/KiCad/KiCad.app/Contents/SharedSupport/symbols//${lib}.kicad_sym`;
      }
      libraries.push(["library", ["logical", this.quote(lib)], ["uri", this.quote(uri)]]);
    }
    return libraries;
  }

  private generateNets(): SExpr {
    const nets: SExpr[] = ["nets"];
    let code = 1;

    const pinMap = new Map<Pin, Component<any>>();
    for (const comp of this.snapshot.components) {
      if (comp.symbol === "Device:DNC") continue;
      for (const [name, pin] of comp.allPins) {
        pinMap.set(pin as Pin, comp);
      }
    }

    const processedNets = new Set<Net>();

    const allNets = new Set<Net>(this.snapshot.nets);
    for (const comp of this.snapshot.components) {
      for (const [_, pin] of comp.allPins) {
        if (pin.net) allNets.add(pin.net);
      }
    }

    for (const net of allNets) {
      if (processedNets.has(net)) continue;
      processedNets.add(net);

      const nodes: SExpr[] = [];

      for (const [pin, comp] of pinMap) {
        if (pin.net === net) {
          let pintype = "passive";
          const symDef = this.library.getSymbol(comp.symbol);
          if (symDef) {
            // Helper to recursively find pin type by pin number
            const findPinType = (expr: SExpr, targetPin: string): string | null => {
              if (!Array.isArray(expr)) return null;

              // Is this a pin definition? (pin "type" "shape" ...)
              if (expr[0] === "pin" && typeof expr[1] === "string" && typeof expr[2] === "string") {
                // Find the (number "X" ...) child
                for (const child of expr) {
                  if (Array.isArray(child) && child[0] === "number" && typeof child[1] === "string") {
                    const num = SExpressionParser.unquote(child[1]);
                    if (num === targetPin) {
                      return expr[1]; // The pin type is the second element
                    }
                  }
                }
              }

              // Recurse
              for (const child of expr) {
                const res = findPinType(child, targetPin);
                if (res) return res;
              }
              return null;
            };

            pintype = findPinType(symDef.definition, pin.name) || "passive";
            if (pintype === "passive") {
              for (const dep of symDef.dependencies) {
                const depType = findPinType(dep, pin.name);
                if (depType) {
                  pintype = depType;
                  break;
                }
              }
            }
          }

          nodes.push(["node", ["ref", this.quote(comp.ref)], ["pin", this.quote(pin.name)], ["pintype", this.quote(pintype)]]);
        }
      }

      nets.push([
        "net",
        ["code", this.quote(code.toString())],
        ["name", this.quote(net.name)],
        ["class", this.quote("Default")],
        ...nodes
      ]);
      code++;
    }

    return nets;
  }

  private addSymbol(symDef: SymbolDefinition) {
    if (this.usedSymbols.has(symDef.name)) return;
    this.usedSymbols.set(symDef.name, symDef);
  }

  private quote(s: string): string {
    return `"${s.replace(/"/g, '\\"')}"`;
  }
}
