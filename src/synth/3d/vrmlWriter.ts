/**
 * Custom VRML 2.0 exporter with per-solid colors.
 *
 * Triangulates each solid via BRepMesh_IncrementalMesh, then writes
 * VRML2 IndexedFaceSet nodes grouped by solid color.
 *
 * KiCad 3D viewer renders VRML2 meshes with full color support.
 */
import * as fs from "fs";
import * as path from "path";
import type { OC, SolidHandle, ColorRGBA } from "./types";

/** Default linear deflection for meshing (mm). Lower = finer mesh. */
const DEFAULT_LINEAR_DEFLECTION = 0.1;
/** Default angular deflection (radians). */
const DEFAULT_ANGULAR_DEFLECTION = 0.5;
/**
 * KiCad interprets VRML coordinates as 1 unit = 2.54 mm (0.1 inch).
 * Multiply mm values by this factor before writing.
 */
const MM_TO_VRML = 1 / 2.54;

interface TriMesh {
    vertices: number[];   // flat [x,y,z, x,y,z, ...]
    indices: number[];     // flat [i0,i1,i2, i0,i1,i2, ...]
}

/**
 * Triangulate a TopoDS_Shape and extract vertex/index data from all faces.
 */
function triangulateShape(oc: OC, shape: any): TriMesh {
    // Mesh the shape
    const pr = new oc.Message_ProgressRange_1();
    const mesher = new oc.BRepMesh_IncrementalMesh_2(
        shape,
        DEFAULT_LINEAR_DEFLECTION,
        false,
        DEFAULT_ANGULAR_DEFLECTION,
        false,
    );
    mesher.Perform(pr);
    pr.delete();

    const vertices: number[] = [];
    const indices: number[] = [];
    let vertexOffset = 0;

    // Iterate all faces
    const explorer = new oc.TopExp_Explorer_2(
        shape,
        oc.TopAbs_ShapeEnum.TopAbs_FACE as any,
        oc.TopAbs_ShapeEnum.TopAbs_SHAPE as any,
    );

    while (explorer.More()) {
        const face = oc.TopoDS.Face_1(explorer.Current());
        const location = new oc.TopLoc_Location_1();
        const handleTri = oc.BRep_Tool.Triangulation(
            face,
            location
        );

        if (!handleTri.IsNull()) {
            const tri = handleTri.get();
            const nbNodes = tri.NbNodes();
            const nbTris = tri.NbTriangles();
            const trsf = location.Transformation();

            // Extract vertices (transformed)
            for (let i = 1; i <= nbNodes; i++) {
                const pt = tri.Node(i);
                pt.Transform(trsf);
                vertices.push(pt.X(), pt.Y(), pt.Z());
            }

            // Extract triangle indices (1-based â†’ 0-based, offset by vertexOffset)
            // Check face orientation to maintain consistent normals
            const orient = face.Orientation_1();
            const reversed = orient === oc.TopAbs_Orientation.TopAbs_REVERSED as any;

            for (let i = 1; i <= nbTris; i++) {
                const triangle = tri.Triangle(i);
                const n1 = triangle.Value(1) - 1 + vertexOffset;
                const n2 = triangle.Value(2) - 1 + vertexOffset;
                const n3 = triangle.Value(3) - 1 + vertexOffset;
                if (reversed) {
                    indices.push(n1, n3, n2);
                } else {
                    indices.push(n1, n2, n3);
                }
            }

            vertexOffset += nbNodes;
        }

        location.delete();
        explorer.Next();
    }

    explorer.delete();
    mesher.delete();

    return { vertices, indices };
}

/**
 * Format a number to 6 decimal places, stripping trailing zeros.
 */
function fmt(n: number): string {
    return n.toFixed(6).replace(/\.?0+$/, "") || "0";
}

/**
 * Write a list of colored solids to a VRML 2.0 file.
 */
export function writeVRML(
    oc: OC,
    solids: SolidHandle[],
    filePath: string,
): void {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }

    const lines: string[] = [];
    lines.push("#VRML V2.0 utf8");
    lines.push("# Generated by pcb_framework 3D pipeline");
    lines.push("");

    for (const solid of solids) {
        const mesh = triangulateShape(oc, solid.shape);
        if (mesh.vertices.length === 0) continue;

        const color: ColorRGBA = solid.color ?? { r: 0.5, g: 0.5, b: 0.5, a: 1 };
        const name = solid.name ?? "solid";

        lines.push(`# ${name}`);
        lines.push("Shape {");
        lines.push("  appearance Appearance {");
        lines.push("    material Material {");
        lines.push(`      diffuseColor ${fmt(color.r)} ${fmt(color.g)} ${fmt(color.b)}`);
        lines.push("      specularColor 0.1 0.1 0.1");
        lines.push("      shininess 0.3");
        if (color.a !== undefined && color.a < 1) {
            lines.push(`      transparency ${fmt(1 - color.a)}`);
        }
        lines.push("    }");
        lines.push("  }");
        lines.push("  geometry IndexedFaceSet {");
        lines.push("    coord Coordinate {");

        // Write vertices
        const coordPoints: string[] = [];
        for (let i = 0; i < mesh.vertices.length; i += 3) {
            coordPoints.push(
                `      ${fmt(mesh.vertices[i] * MM_TO_VRML)} ${fmt(mesh.vertices[i + 1] * MM_TO_VRML)} ${fmt(mesh.vertices[i + 2] * MM_TO_VRML)}`
            );
        }
        lines.push("      point [");
        lines.push(coordPoints.join(",\n"));
        lines.push("      ]");
        lines.push("    }");

        // Write face indices (VRML uses -1 as face terminator)
        const idxParts: string[] = [];
        for (let i = 0; i < mesh.indices.length; i += 3) {
            idxParts.push(`${mesh.indices[i]},${mesh.indices[i + 1]},${mesh.indices[i + 2]},-1`);
        }
        lines.push("    coordIndex [");
        lines.push("      " + idxParts.join(",\n      "));
        lines.push("    ]");

        lines.push("  }");
        lines.push("}");
        lines.push("");
    }

    fs.writeFileSync(filePath, lines.join("\n"), "utf-8");
}
