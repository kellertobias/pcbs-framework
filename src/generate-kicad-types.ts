import * as fs from "fs";
import * as path from "path";

/**
 * Script to generate TypeScript types for KiCad symbols and footprints.
 * Scans standard KiCad library paths on macOS and project-local libraries.
 */

const KICAD_PATH = "/Applications/KiCad/KiCad.app/Contents/SharedSupport";
const SYMBOLS_DIR = path.join(KICAD_PATH, "symbols");
const FOOTPRINTS_DIR = path.join(KICAD_PATH, "footprints");

const PROJECT_LIB_DIR = path.join(process.cwd(), ".kicad");

const OUTPUT_FILE = path.join(process.cwd(), "framework/types/kicad-library.ts");

function parseSymbolsInFile(filePath: string, libName: string): string[] {
    if (!fs.existsSync(filePath)) return [];
    const content = fs.readFileSync(filePath, "utf-8");
    const names: string[] = [];

    // Quick regex to find all (symbol "NAME" ...) top-level patterns
    const matches = content.matchAll(/\(symbol\s+"([^"]+)"/g);
    for (const match of matches) {
        const symName = match[1];
        // Skip if it contains a colon already (might be an alias or complex name)
        if (!symName.includes(":")) {
            names.push(`${libName}:${symName}`);
        } else {
            names.push(symName);
        }
    }
    return names;
}

function getSymbolNames(): string[] {
    const names: string[] = [];

    // System libraries
    if (fs.existsSync(SYMBOLS_DIR)) {
        const symbolFiles = fs.readdirSync(SYMBOLS_DIR).filter(f => f.endsWith(".kicad_sym"));
        for (const file of symbolFiles) {
            const libName = path.basename(file, ".kicad_sym");
            names.push(...parseSymbolsInFile(path.join(SYMBOLS_DIR, file), libName));
        }
    }

    // Project library
    const projectSymLib = path.join(PROJECT_LIB_DIR, "Project_Symbols.kicad_sym");
    if (fs.existsSync(projectSymLib)) {
        names.push(...parseSymbolsInFile(projectSymLib, "Project_Symbols"));
    }

    // Built-in markers
    names.push("Device:DNC");
    names.push("Connector:TestPoint");

    return [...new Set(names)].sort();
}

function getFootprintNames(): string[] {
    const names: string[] = [];

    // System libraries
    if (fs.existsSync(FOOTPRINTS_DIR)) {
        const prettyDirs = fs.readdirSync(FOOTPRINTS_DIR).filter(d => d.endsWith(".pretty"));
        for (const dir of prettyDirs) {
            const libName = path.basename(dir, ".pretty");
            const modFiles = fs.readdirSync(path.join(FOOTPRINTS_DIR, dir)).filter(f => f.endsWith(".kicad_mod"));

            for (const file of modFiles) {
                const fpName = path.basename(file, ".kicad_mod");
                names.push(`${libName}:${fpName}`);
            }
        }
    }

    // Project library
    const projectFpLib = path.join(PROJECT_LIB_DIR, "Project_Footprints.pretty");
    if (fs.existsSync(projectFpLib)) {
        const modFiles = fs.readdirSync(projectFpLib).filter(f => f.endsWith(".kicad_mod"));
        for (const file of modFiles) {
            const fpName = path.basename(file, ".kicad_mod");
            names.push(`Project_Footprints:${fpName}`);
        }
    }

    // Built-in markers
    names.push("DNC");
    names.push("TestPoint:TestPoint_Pad_D2.5mm");

    return [...new Set(names)].sort();
}

function generateTypes() {
    console.log("Generating KiCad library types (including project libraries and markers)...");

    const symbols = getSymbolNames();
    const footprints = getFootprintNames();

    const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by scripts/generate-kicad-types.ts
 */

export type KicadLibrarySymbol =
${symbols.map(s => `  | "${s}"`).join("\n")};

export type KicadLibraryFootprint =
${footprints.map(f => `  | "${f}"`).join("\n")};
`;

    const dir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(OUTPUT_FILE, content, "utf-8");
    console.log(`Generated ${symbols.length} symbols and ${footprints.length} footprints in ${OUTPUT_FILE}`);
}

generateTypes();
